{"majorversion": 3, "classmap": {"ConfigTest": {"name": "ConfigTest", "namespace": "", "module": "test", "guessedname": "ConfigTest", "file": "2-config-test.js", "guessedtype": "property", "shortname": "ConfigTest", "description": "<p>Unit tests for the node-config library.  To run type:</p>\n<pre>npm test config</pre>"}, "Config": {"name": "Config", "namespace": "", "module": "config", "methods": {"watchForConfigFileChanges": {"description": "Monitor the runtime.json file for configuration changes.\n<p>\nLong running processes can call this method at startup to have node-config\nautomatically monitor and apply changes made to the config/runtime.json file.\n</p>\n<p>\nThis paradigm allows for manual changes to running application servers,\nand for multi-node application servers to keep in sync.\n</p>\n<p>\nThis method attaches a file watcher onto the runtime.json file, reloading\nthe file on change and merging the new values into the CONFIG object.\n</p>", "guessedname": "watchForConfigFileChanges", "guessedtype": "function"}, "_attachProtoDeep": {"return": {"type": "", "description": "toObject"}, "description": "Attach the Config class prototype to all config objects recursively.\n<p>\nThis allows you to do anything with CONFIG sub-objects as you can do with\nthe top-level CONFIG object.  It's so you can do this:\n</p>\n<pre>\nvar CUST_CONFIG = require('config').Customer;\nCUST_CONFIG.watch(...)\n</pre>", "protected": "", "params": [{"type": "", "name": "toObject", "description": ""}, {"type": "", "name": "depth", "description": ""}], "guessedname": "_attachProtoDeep", "guessedtype": "function"}, "_persistConfigsOnChange": {"protected": "", "params": [{"type": "object", "name": "object", "description": "  - The config object to watch"}], "description": "<p>\nWatch the specified object for a change in properties, and persist changes\nto runtime.json when a change is detected.\n</p>", "guessedname": "_persistConfigsOnChange", "guessedtype": "function"}, "setModuleDefaults": {"return": {"type": "object", "description": "moduleConfig  - The module level configuration object."}, "params": [{"type": "string", "name": "moduleName", "description": "  - Name of your module."}, {"type": "object", "name": "defaultProperties", "description": "  - The default module configuration."}], "description": "<p>\nSet default configurations for a node.js module.\n</p>\n<p>\nThis allows module developers to attach their configurations onto the\ndefault configuration object so they can be configured by the consumers\nof the module.\n</p>\n<p>Using the function within your module:</p>\n<pre>\nvar CONFIG = require(\"config\");\nCONFIG.setModuleDefaults(\"MyModule\", {\n&nbsp;&nbsp;templateName: \"t-50\",\n&nbsp;&nbsp;colorScheme: \"green\"\n});\n<br>\n// Template name may be overridden by application config files\nconsole.log(\"Template: \" + CONFIG.MyModule.templateName);\n</pre>\n<p>\nThe above example results in a \"MyModule\" element of the configuration\nobject, containing an object with the specified default values.\n</p>", "guessedname": "setModuleDefaults", "guessedtype": "function"}, "watch": {"return": {"type": "object", "description": "object  - The original object is returned - for chaining."}, "params": [{"type": "object", "name": "object", "description": "  - The object to watch."}, {"type": "string", "name": "property", "description": "  - The property name to watch.  Watch all object properties if null."}, {"type": "function(object, propertyName, priorValue, newValue)", "name": "handler", "description": "  - Handler called when a property change is detected.\nThe handler is run along with other handlers registered for notification.\nIf your handler changes the value of the property, that change is applied after all handlers have finished processing the current change.\nThen all handlers (including this one) will be called again with the newly changed value."}, {"type": "integer", "name": "depth", "description": "  (optional) - If watching all object properties or if the specified property is an object, this specifies the depth of the object graph to watch for changes.  Default 6."}], "description": "<p>Monitor a configuration value for runtime changes.</p>\n<p>\nConfiguration values can be changed at runtime by the application or by a\nmanual change to the config/runtime.json  file.\nThis method lets you specify a function to run when a configuration\nvalue changes.\n</p>\n<p><i>\nThis was built for monitoring changes to configuration values,\nbut it can be used for watching changes to <u>any</u> javascript object.\n</i></p>\n<p>Example:</p>\n<pre>\nvar CONFIG = require('config').customer;\n...\n// Watch for any changes to the customer configuration\nCONFIG.watch(CONFIG, null, function(object, propertyName, priorValue, newValue) {\n&nbsp;console.log(\"Customer configuration \" + propertyName + \" changed from \" + priorValue + \" to \" + newValue);\n});\n</pre>", "guessedname": "watch", "guessedtype": "function"}, "_stripComments": {"return": {"type": "string", "description": "The string with comments stripped."}, "description": "Strip all Javascript type comments from the string.\nThe string is usually a file loaded from the O/S, containing\nnewlines and javascript type comments.\nThanks to James Padolsey, and all who conributed to this implementation.\nhttp://james.padolsey.com/javascript/javascript-comment-removal-revisted/", "protected": "", "params": [{"type": "string", "name": "fileString", "description": "  The string to strip comments from"}], "guessedname": "_stripComments", "guessedtype": "function"}, "makeHidden": {"return": {"type": "object", "description": "object  - The original object is returned - for chaining."}, "params": [{"type": "object", "name": "object", "description": "  - The object to make a hidden property into."}, {"type": "string", "name": "property", "description": "  - The name of the property to make hidden."}, {"type": "mixed", "name": "value", "description": "  - (optional) Set the property value to this (otherwise leave alone)"}], "description": "<p>Make a configuration property hidden so it doesn't appear when enumerating\nelements of the object.</p>\n<p>\nThe property still exists and can be read from and written to, but it won't\nshow up in for ... in loops, Object.keys(), or JSON.stringify() type methods.\n</p>\n<p>\nIf the property already exists, it will be made hidden.  Otherwise it will\nbe created as a hidden property with the specified value.\n</p>\n<p><i>\nThis method was built for hiding configuration values, but it can be applied\nto <u>any</u> javascript object.\n</i></p>\n<p>Example:</p>\n<pre>\nvar CONFIG = require('config');\n...\n// Hide the Amazon S3 credentials\nCONFIG.makeHidden(CONFIG.amazonS3, 'access_id');\nCONFIG.makeHidden(CONFIG.amazonS3, 'secret_key');\n</pre>", "guessedname": "makeHidden", "guessedtype": "function"}, "_equalsDeep": {"return": {"type": "boolean", "description": "True if both objects have equivalent contents"}, "description": "Return true if two objects have equal contents.", "protected": "", "params": [{"type": "object", "name": "object1", "description": "  The object to compare from"}, {"type": "object", "name": "object2", "description": "  The object to compare with"}, {"type": "integer", "name": "depth", "description": "  An optional depth to prevent recursion.  Default: 20."}], "guessedname": "_equalsDeep", "guessedtype": "function"}, "_stripYamlComments": {"return": {"type": "string", "description": "The string with comments stripped."}, "description": "Strip YAML comments from the string\nThe 2.0 yaml parser doesn't allow comment-only or blank lines.  Strip them.", "protected": "", "params": [{"type": "string", "name": "fileString", "description": "  The string to strip comments from"}], "guessedname": "_stripYamlComments", "guessedtype": "function"}, "makeImmutable": {"return": {"type": "object", "description": "object  - The original object is returned - for chaining."}, "params": [{"type": "object", "name": "object", "description": "  - The object to attach an immutable property into."}, {"type": "string", "name": "property", "description": "  - The name of the property to make immutable."}, {"type": "mixed", "name": "value", "description": "  - (optional) Set the property value to this (otherwise leave alone)"}], "description": "<p>Make a configuration property immutable (assuring it cannot be changed\nfrom the current value).</p>\n<p>\nThis operation cannot be un-done.\n</p>\n<p><i>\nThis method was built for disabling runtime changes to configuration values,\nbut it can be applied to <u>any</u> javascript object.\n</i></p>\n<p>Example:</p>\n<pre>\nvar CONFIG = require('config').customer;\n...\n// Obtain a DB connection using CONFIG parameters\ndatabase.open(CONFIG.db.name, CONFIG.db.port);\n...\n// Don't allow database changes after connect\nCONFIG.makeImmutable(CONFIG.db, 'name');\nCONFIG.makeImmutable(CONFIG.db, 'port');\n</pre>", "guessedname": "makeImmutable", "guessedtype": "function"}, "_cloneDeep": {"return": {"type": "object", "description": "A new object with the elements copied from the copyFrom object"}, "description": "Return a deep copy of the specified object.\nThis returns a new object with all elements copied from the specified\nobject.  Deep copies are made of objects and arrays so you can do anything\nwith the returned object without affecting the input object.", "protected": "", "params": [{"type": "object", "name": "copyFrom", "description": "  The original object to copy from"}, {"type": "integer", "name": "depth", "description": "  An optional depth to prevent recursion.  Default: 20."}], "guessedname": "_cloneDeep", "guessedtype": "function"}, "_loadFileConfigs": {"protected": "", "return": {"type": "this", "description": "The configuration object"}, "description": "Load the individual file configurations.\n<p>\nThis method builds a map of filename to the configuration object defined\nby the file.  The search order is:\n</p>\n<pre>\ndefault.EXT\n(hostname).EXT\n(deployment).EXT\n(hostname)-(deployment).EXT\nruntime.json\n</pre>\n<p>\nEXT can be yaml, coffee, json, or js signifying the file type.\nyaml is in YAML format, coffee is a coffee-script,\njson is in strict JSON format, and js is a javascript executable file that is\nrequire()'d with module.exports being the config object.\n</p>\n<p>\n(hostname) is the $HOST environment variable if set, otherwise the\nhostname found from require('os').hostname()\n</p>\n<p>\n(deployment) is the deployment type, found in the $NODE_ENV environment\nvariable.  Defaults to 'development'.\n</p>\n<p>\nThe runtime.json file contains configuration changes made at runtime either\nmanually, or by the application setting a configuration value.\n</p>", "guessedname": "_loadFileConfigs", "guessedtype": "function"}, "constructor": {"return": {"type": "object", "description": "CONFIG  - The top level configuration object"}, "description": "<p>Get the configuration object.</p>\n<p>\nThe configuration object is a shared singleton object within the applicaiton,\nattained by calling require('config').\n</p>\n<p>\nUsually you'll specify a CONFIG variable at the top of your .js file\nfor file/module scope. If you want the root of the object, you can do this:\n</p>\n<pre>\nvar CONFIG = require('config');\n</pre>\n<p>\nSometimes you only care about a specific sub-object within the CONFIG\nobject.  In that case you could do this at the top of your file:\n</p>\n<pre>\nvar CONFIG = require('config').customer;\nor\nvar CUSTOMER_CONFIG = require('config').customer;\n</pre>\n<script type=\"text/javascript\">\ndocument.getElementById(\"showProtected\").style.display = \"block\";\n</script>", "guessedname": "Config", "guessedtype": "function"}, "_diffDeep": {"return": {"type": "object", "description": "A differential object, which if extended onto object1 would\nresult in object2."}, "description": "Returns an object containing all elements that differ between two objects.\n<p>\nThis method was designed to be used to create the runtime.json file\ncontents, but can be used to get the diffs between any two Javascript objects.\n</p>\n<p>\nIt works best when object2 originated by deep copying object1, then\nchanges were made to object2, and you want an object that would give you\nthe changes made to object1 which resulted in object2.\n</p>", "protected": "", "params": [{"type": "object", "name": "object1", "description": "  The base object to compare to"}, {"type": "object", "name": "object2", "description": "  The object to compare with"}, {"type": "integer", "name": "depth", "description": "  An optional depth to prevent recursion.  Default: 20."}], "guessedname": "_diffDeep", "guessedtype": "function"}, "_isObject": {"return": {"type": "boolean", "description": "TRUE if the arg is an object, FALSE if not"}, "description": "Is the specified argument a regular javascript object?\nThe argument is an object if it's a JS object, but not an array.", "protected": "", "params": [{"type": "MIXED", "name": "arg", "description": "  An argument of any type."}], "guessedname": "_isObject", "guessedtype": "function"}, "_parseFile": {"return": {"type": "configObject", "description": "The configuration object parsed from the file"}, "description": "Parse and return the specified configuration file.\nIf the file exists in the application config directory, it will\nparse and return it as a JavaScript object.\nThe file extension determines the parser to use.\n.js = File to run that has a module.exports containing the config object\n.json = File is parsed using JSON.parse()\n.coffee = File to run that has a module.exports with coffee-script containing the config object\n.yaml = Parsed with a YAML parser\nIf the file doesn't exist, a null will be returned.\nIf the file can't be parsed, an exception will be thrown.", "protected": "", "params": [{"type": "string", "name": "fullFilename", "description": "  The full file path and name"}], "guessedname": "_parseFile", "guessedtype": "function"}, "_extendDeep": {"return": {"type": "object", "description": "The altered mergeInto object is returned"}, "description": "Extend an object, and any object it contains.\nThis does not replace deep objects, but dives into them\nreplacing individual elements instead.", "protected": "", "params": [{"type": "object", "name": "mergeInto", "description": "  The object to merge into"}, {"type": "object...", "name": "mergeFrom...", "description": "  - Any number of objects to merge from"}, {"type": "integer", "name": "depth", "description": "  An optional depth to prevent recursion.  Default: 20."}], "guessedname": "_extendDeep", "guessedtype": "function"}}, "file": "config.js", "shortname": "Config", "description": "<p>Runtime Application Configurations</p>\n<p>\nThe config module exports a singleton object representing all runtime\nconfigurations for this application deployment.\n</p>\n<p>\nApplication configurations are stored in files within the config directory\nof your application.  The default configuration file is loaded, followed\nby files specific to the deployment type (development, testing, staging,\nproduction, etc.).\n</p>\n<p>\nFor example, with the following config/default.yaml file:\n</p>\n<pre>\n...\ncustomer:\n&nbsp;&nbsp;initialCredit: 500\n&nbsp;&nbsp;db:\n&nbsp;&nbsp;&nbsp;&nbsp;name: customer\n&nbsp;&nbsp;&nbsp;&nbsp;port: 5984\n...\n</pre>\n<p>\nThe following code loads the customer section into the CONFIG variable:\n<p>\n<pre>\nvar CONFIG = require('config').customer;\n...\nnewCustomer.creditLimit = CONFIG.initialCredit;\ndatabase.open(CONFIG.db.name, CONFIG.db.port);\n...\n</pre>"}, "ProtectedTest": {"name": "ProtectedTest", "namespace": "", "module": "test", "guessedname": "PrivateTest", "file": "1-protected-test.js", "guessedtype": "property", "shortname": "ProtectedTest", "description": "<p>Tests for underlying node-config utilities.  To run type:</p>\n<pre>npm test config</pre>"}}, "version": "0.4.10", "modules": {"test": {"description": "<p>Unit tests</p>", "submodules": [], "classlist": ["ProtectedTest", "ConfigTest"], "filelist": ["1-protected-test.js", "2-config-test.js", "default.js"], "subdata": {}, "name": "test"}, "config": {"description": "<p>Runtime Application Configurations</p>\n<p>\nThe config module exports a singleton object representing all runtime\nconfigurations for this application deployment.\n</p>\n<p>\nApplication configurations are stored in files within the config directory\nof your application.  The default configuration file is loaded, followed\nby files specific to the deployment type (development, testing, staging,\nproduction, etc.).\n</p>\n<p>\nFor example, with the following config/default.yaml file:\n</p>\n<pre>\n...\ncustomer:\n&nbsp;&nbsp;initialCredit: 500\n&nbsp;&nbsp;db:\n&nbsp;&nbsp;&nbsp;&nbsp;name: customer\n&nbsp;&nbsp;&nbsp;&nbsp;port: 5984\n...\n</pre>\n<p>\nThe following code loads the customer section into the CONFIG variable:\n<p>\n<pre>\nvar CONFIG = require('config').customer;\n...\nnewCustomer.creditLimit = CONFIG.initialCredit;\ndatabase.open(CONFIG.db.name, CONFIG.db.port);\n...\n</pre>", "submodules": [], "classlist": ["Config"], "filelist": ["config.js"], "subdata": {}, "name": "config"}}, "filemap": {"default.js": {"classlist": [], "name": "default.js", "module": "test"}, "2-config-test.js": {"classlist": ["ConfigTest"], "name": "2-config-test.js", "module": "test"}, "config.js": {"classlist": ["Config"], "name": "config.js", "module": "config"}, "1-protected-test.js": {"classlist": ["ProtectedTest"], "name": "1-protected-test.js", "module": "test"}}}